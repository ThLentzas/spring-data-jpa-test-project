package com.example.spring_data_jpa.article;

import java.time.LocalDate;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;

import com.example.spring_data_jpa.AbstractUnitTest;
import com.example.spring_data_jpa.topic.Topic;
import com.example.spring_data_jpa.topic.TopicRepository;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.AssertionsForClassTypes.tuple;


class ArticleRepositoryTest extends AbstractUnitTest {
    @Autowired
    private TopicRepository topicRepository;
    @Autowired
    private ArticleRepository articleRepository;

    /*
        We can't set created date because it is generated by the DB. Even if we do, it will be overwritten.
     */
    @BeforeEach
    void setup() {
        Topic cloud = this.topicRepository.save(new Topic("Cloud"));
        Topic science = this.topicRepository.save(new Topic("Science"));
        Topic education = this.topicRepository.save(new Topic("Education"));
        Topic cooking = this.topicRepository.save(new Topic("Cooking"));
        Topic chemistry = this.topicRepository.save(new Topic("Chemistry"));

        Article loadBalancer = new Article(
                "Load Balancer",
                "Content about load balancing",
                Set.of(cloud, science));
        loadBalancer.setStatus(ArticleStatus.PUBLISHED);
        loadBalancer.setPublishedDate(LocalDate.parse("2023-05-18"));
        this.articleRepository.save(loadBalancer);

        Article cloudEngineering = new Article(
                "Cloud Engineering",
                "Content about cloud engineering",
                Set.of(cloud, science));
        cloudEngineering.setStatus(ArticleStatus.APPROVED);
        this.articleRepository.save(cloudEngineering);

        Article cookingArticle = new Article(
                "Cooking",
                "Content about cooking",
                Set.of(cooking));
        cookingArticle.setStatus(ArticleStatus.APPROVED);
        this.articleRepository.save(cookingArticle);

        Article educationSystem = new Article(
                "Education System",
                "Content about education system",
                Set.of(education));
        educationSystem.setStatus(ArticleStatus.SUBMITTED);
        this.articleRepository.save(educationSystem);

        Article chemicalEngineering = new Article(
                "Chemical Engineering",
                "Content about chemical engineering",
                Set.of(chemistry, science));
        chemicalEngineering.setStatus(ArticleStatus.SUBMITTED);
        this.articleRepository.save(chemicalEngineering);

        Article careerMotivations = new Article(
                "Career Motivations",
                "Content about career motivation",
                Set.of(education));
        careerMotivations.setStatus(ArticleStatus.PUBLISHED);
        careerMotivations.setPublishedDate(LocalDate.parse("2023-09-21"));
        this.articleRepository.save(careerMotivations);
    }

    /*
        We have to set up the created dates after inserting the records in the db, because the db generates
        automatically the created dates so setting them from before wouldn't work.

        The reason why we don't have to call save again is because Hibernate is aware of the articles being in the
        context so in the end it will mimic the changes in the db.

        articles.get(0).setTopics(new HashSet<>(articles.get(0).getTopics())); => in Hibernate when entities are fetched
        from the database and their collections are automatically made immutable we have to create a mutable one first
        before saving them again
     */
    @BeforeEach
    void setupDates() {
        List<Article> articles = this.articleRepository.findArticlesByTitleContainingIgnoringCase(
                "Chemical Engineering");
        articles.get(0).setCreatedDate(LocalDate.parse("2023-05-01"));
        articles.get(0).setTopics(new HashSet<>(articles.get(0).getTopics()));
        this.articleRepository.save(articles.get(0));

        articles = this.articleRepository.findArticlesByTitleContainingIgnoringCase("Cloud Engineering");
        articles.get(0).setCreatedDate(LocalDate.parse("2023-10-22"));
        articles.get(0).setTopics(new HashSet<>(articles.get(0).getTopics()));
        this.articleRepository.save(articles.get(0));
    }

    @Test
    void shouldFindArticleById() {
        this.articleRepository.findArticleByIdFetchingTopics(1L).ifPresent(
                actual -> {
                    assertThat(actual.getId()).isEqualTo(1);
                    assertThat(actual.getTitle()).isEqualTo("Load Balancer");
                    assertThat(actual.getTopics().stream()
                            .map(Topic::getName)
                            .collect(Collectors.toSet()))
                            .hasSize(2)
                            .containsExactly("Cloud", "Science");
                }
        );
    }

    /*
        containsExactlyInAnyOrder() and then passing Article objects would not have worked because the two objects would
        not be the same due to different created date, id status etc.

        If we wanted more values other than the tile we could use a tuple like. Tuples are use for more than 1 value.

        assertThat(articles)
            .extracting(Article::getTitle, Article::getContent)
            .containsExactlyInAnyOrder(
                tuple("Chemical Engineering", "Content about chemical engineering"),
                tuple("Cloud Engineering", "Content about cloud engineering")
        );
     */
    @Test
    void shouldFindArticlesByTitleContainingIgnoringCase() {
        List<Article> actual = this.articleRepository.findArticlesByTitleContainingIgnoringCase("Engineer");

        assertThat(actual).hasSize(2);
        assertThat(actual)
                .extracting(Article::getTitle)
                .containsExactlyInAnyOrder("Chemical Engineering", "Cloud Engineering");
    }

    @Test
    void shouldFindArticlesByContentContainingIgnoringCase() {
        List<Article> actual = this.articleRepository.findArticlesByContentContainingIgnoringCase("conTeNt");

        assertThat(actual).hasSize(6);
        assertThat(actual)
                .extracting(Article::getContent)
                .containsExactlyInAnyOrder(
                        "Content about load balancing",
                        "Content about cloud engineering",
                        "Content about chemical engineering",
                        "Content about cooking",
                        "Content about education system",
                        "Content about career motivation"
                );
    }

    @Test
    void shouldFindPublishedArticlesOrderedByPublishedDateDesc() {
        List<Article> actual = this.articleRepository.findPublishedArticlesOrderByPublishedDateDesc(
                ArticleStatus.PUBLISHED);

        assertThat(actual)
                .hasSize(2)
                .isSortedAccordingTo(Comparator
                        .comparing(Article::getPublishedDate, Comparator.reverseOrder()));

        assertThat(actual)
                .extracting(
                        Article::getTitle,
                        Article::getStatus,
                        article -> article.getTopics().stream()
                                .map(Topic::getName)
                                .collect(Collectors.toSet()))
                .containsExactly(
                        tuple("Career Motivations", ArticleStatus.PUBLISHED, Set.of("Education")),
                        tuple("Load Balancer", ArticleStatus.PUBLISHED, Set.of("Cloud", "Science"))
                );
    }


    @Test
    void shouldFindNonPublishedArticlesOrderedByStatusAndCreatedDateDesc() {
        List<Article> actual = this.articleRepository.findNonPublishedArticlesOrderByStatusAndCreatedDateDesc(
                ArticleStatus.PUBLISHED);

        assertThat(actual)
                .hasSize(4)
                .isSortedAccordingTo(Comparator
                        .comparing(Article::getStatus, Comparator.reverseOrder())
                        .thenComparing(Article::getCreatedDate, Comparator.reverseOrder()));

        /*
            Checks that the list contains exactly the given elements in the given order. ContainsExactly  asserts both
            the order and the values.
         */
        assertThat(actual)
                .extracting(
                        Article::getTitle,
                        Article::getStatus,
                        article -> article.getTopics().stream()
                                .map(Topic::getName)
                                .collect(Collectors.toSet()))
                .containsExactly(
                        tuple("Cooking", ArticleStatus.APPROVED, Set.of("Cooking")),
                        tuple("Cloud Engineering", ArticleStatus.APPROVED, Set.of("Cloud", "Science")),
                        tuple("Education System", ArticleStatus.SUBMITTED, Set.of("Education")),
                        tuple("Chemical Engineering", ArticleStatus.SUBMITTED, Set.of("Chemistry", "Science"))
                );
    }

    @Test
    void shouldFindArticlesByStatusOrderedByCreatedDateDesc() {
        List<Article> actual = this.articleRepository.findArticlesByStatusOrderByCreatedDateDesc(
                ArticleStatus.SUBMITTED);

        assertThat(actual)
                .hasSize(2)
                .isSortedAccordingTo(Comparator
                        .comparing(Article::getCreatedDate, Comparator.reverseOrder()));

        assertThat(actual)
                .extracting(
                        Article::getTitle,
                        Article::getStatus,
                        article -> article.getTopics().stream()
                                .map(Topic::getName)
                                .collect(Collectors.toSet()))
                .containsExactly(
                        tuple("Education System", ArticleStatus.SUBMITTED, Set.of("Education")),
                        tuple("Chemical Engineering", ArticleStatus.SUBMITTED, Set.of("Chemistry", "Science"))
                );
    }

    @Test
    void shouldFindPublishedArticlesWithPublishedDateBetweenOrderByPublishedDateDesc() {
        LocalDate startDate = LocalDate.parse("2023-05-10");
        LocalDate endDate = LocalDate.parse("2023-06-10");

        List<Article> actual = this.articleRepository.
                findPublishedArticlesWithPublishedDateBetweenOrderByPublishedDateDesc(
                        ArticleStatus.PUBLISHED,
                        startDate,
                        endDate);

        assertThat(actual)
                .hasSize(1)
                .isSortedAccordingTo(Comparator
                        .comparing(Article::getPublishedDate, Comparator.reverseOrder()));

        assertThat(actual)
                .hasSize(1)
                .extracting(
                        Article::getTitle,
                        Article::getStatus,
                        article -> article.getTopics().stream()
                                .map(Topic::getName)
                                .collect(Collectors.toSet()))
                .containsExactly(
                        tuple("Load Balancer", ArticleStatus.PUBLISHED, Set.of("Cloud", "Science"))
                );
    }

    @Test
    void shouldFindNonPublishedArticlesWithCreatedDateBetweenOrderByCreatedDateDesc() {
        LocalDate startDate = LocalDate.parse("2023-04-01");
        LocalDate endDate = LocalDate.parse("2023-10-23");

        List<Article> actual = this.articleRepository
                .findNonPublishedArticlesWithCreatedDateBetweenOrderByCreatedDesc(
                        ArticleStatus.PUBLISHED,
                        startDate,
                        endDate);

        assertThat(actual)
                .hasSize(2)
                .isSortedAccordingTo(Comparator
                        .comparing(Article::getCreatedDate, Comparator.reverseOrder()));

        assertThat(actual)
                .hasSize(2)
                .extracting(
                        Article::getTitle,
                        Article::getStatus,
                        article -> article.getTopics().stream()
                                .map(Topic::getName)
                                .collect(Collectors.toSet()))
                .containsExactly(
                        tuple("Cloud Engineering", ArticleStatus.APPROVED, Set.of("Cloud", "Science")),
                        tuple("Chemical Engineering", ArticleStatus.SUBMITTED, Set.of("Chemistry", "Science"))
                );
    }

    @Test
    void shouldFindArticlesByTopicId() {
        this.topicRepository.findByNameIgnoreCase("Science").ifPresent(topic -> {
            List<Article> actual = this.articleRepository.findArticlesByTopicId(topic.getId());

            assertThat(actual)
                    .hasSize(3)
                    .extracting(Article::getTitle,
                            article -> article.getTopics().stream()
                                    .map(Topic::getName)
                                    .collect(Collectors.toSet()))
                    .containsExactlyInAnyOrder(
                            tuple("Cloud Engineering", Set.of("Cloud", "Science")),
                            tuple("Chemical Engineering", Set.of("Chemistry", "Science")),
                            tuple("Load Balancer", Set.of("Cloud", "Science"))
                    );
        });
    }
}
